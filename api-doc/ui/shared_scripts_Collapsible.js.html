---
layout: api-doc
id: api-doc
---

<div class="ml-wrapper">
    <main role="main">
        <section>
            <div class="ml-bounds mesh-row">
                <div class="mesh-col-12 mesh-col-m-9">
                    <h1>Source: shared/scripts/Collapsible.js</h1>
                    


    
    <section>
        <article>
            <pre class="prettyprint source"><code>(function (ch) {
    'use strict';

    var toggleEffects = {
        'slideDown': 'slideUp',
        'slideUp': 'slideDown',
        'fadeIn': 'fadeOut',
        'fadeOut': 'fadeIn'
    };

    /**
     * The Collapsible class gives to components the ability to shown or hidden its container.
     * @memberOf ch
     * @mixin
     * @returns {Function} Returns a private function.
     */
    function Collapsible() {

        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this,
            triggerClass = 'ch-' + this.name + '-trigger-on',
            fx = this._options.fx,
            useEffects = (ch.support.transition &amp;&amp; fx !== 'none' &amp;&amp; fx !== false),
            pt, pb;

        function showCallback(e) {
            if (useEffects) {
                ch.util.classList(that.container).remove('ch-fx-' + fx);

                // TODO: Use original height when it is defined
                if (/^slide/.test(fx)) {
                    that.container.style.height = '';
                }
            }
            ch.util.classList(that.container).remove('ch-hide');
            that.container.setAttribute('aria-hidden', 'false');

            if (e) {
                e.target.removeEventListener(e.type, showCallback);
            }

            /**
             * Event emitted when the component is shown.
             * @event ch.Collapsible#show
             * @example
             * // Subscribe to "show" event.
             * collapsible.on('show', function () {
             *     // Some code here!
             * });
             */
            that.emit('show');
        }

        function hideCallback(e) {
            if (useEffects) {
                ch.util.classList(that.container).remove('ch-fx-' + toggleEffects[fx]);
                that.container.style.display = '';
                if (/^slide/.test(fx)) {
                    that.container.style.height = '';
                }
            }
            ch.util.classList(that.container).add('ch-hide');
            that.container.setAttribute('aria-hidden', 'true');

            if (e) {
                e.target.removeEventListener(e.type, hideCallback);
            }

            /**
             * Event emitted when the component is hidden.
             * @event ch.Collapsible#hide
             * @example
             * // Subscribe to "hide" event.
             * collapsible.on('hide', function () {
             *     // Some code here!
             * });
             */
            that.emit('hide');
        }

        this._shown = false;

        /**
         * Shows the component container.
         * @function
         * @private
         */
        this._show = function () {

            that._shown = true;

            if (that.trigger !== undefined) {
                ch.util.classList(that.trigger).add(triggerClass);
            }

            /**
             * Event emitted before the component is shown.
             * @event ch.Collapsible#beforeshow
             * @example
             * // Subscribe to "beforeshow" event.
             * collapsible.on('beforeshow', function () {
             *     // Some code here!
             * });
             */
            that.emit('beforeshow');

            // Animate or not
            if (useEffects) {
                var _h = 0;

                // Be sure to remove an opposite class that probably exist and
                // transitionend listener for an opposite transition, aka $.fn.stop(true, true)
                ch.Event.removeListener(that.container, ch.support.transition.end, hideCallback);
                ch.util.classList(that.container).remove('ch-fx-' + toggleEffects[fx]);

                ch.Event.addListener(that.container, ch.support.transition.end, showCallback);

                // Reveal an element before the transition
                that.container.style.display = 'block';

                // Set margin and padding to 0 to prevent content jumping at the transition end
                if (/^slide/.test(fx)) {
                    // Cache the original paddings for the first time
                    if (!pt || !pb) {
                        pt = ch.util.getStyles(that.container, 'padding-top');
                        pb = ch.util.getStyles(that.container, 'padding-bottom');

                        that.container.style.marginTop = that.container.style.marginBottom =
                            that.container.style.paddingTop = that.container.style.paddingBottom ='0px';
                    }

                    that.container.style.opacity = '0.01';
                    _h = that.container.offsetHeight;
                    that.container.style.opacity = '';
                    that.container.style.height = '0px';
                }

                // Transition cannot be applied at the same time when changing the display property
                setTimeout(function() {
                    if (/^slide/.test(fx)) {
                        that.container.style.height = _h + 'px';
                    }
                    that.container.style.paddingTop = pt;
                    that.container.style.paddingBottom = pb;
                    ch.util.classList(that.container).add('ch-fx-' + fx);
                }, 0);
            } else {
                showCallback();
            }

            that.emit('_show');

            return that;
        };

        /**
         * Hides the component container.
         * @function
         * @private
         */
        this._hide = function () {

            that._shown = false;

            if (that.trigger !== undefined) {
                ch.util.classList(that.trigger).remove(triggerClass);
            }

            /**
             * Event emitted before the component is hidden.
             * @event ch.Collapsible#beforehide
             * @example
             * // Subscribe to "beforehide" event.
             * collapsible.on('beforehide', function () {
             *     // Some code here!
             * });
             */
            that.emit('beforehide');

            // Animate or not
            if (useEffects) {
                // Be sure to remove an opposite class that probably exist and
                // transitionend listener for an opposite transition, aka $.fn.stop(true, true)
                ch.Event.removeListener(that.container, ch.support.transition.end, showCallback);
                ch.util.classList(that.container).remove('ch-fx-' + fx);

                ch.Event.addListener(that.container, ch.support.transition.end, hideCallback);
                // Set margin and padding to 0 to prevent content jumping at the transition end
                if (/^slide/.test(fx)) {
                    that.container.style.height = ch.util.getStyles(that.container, 'height');
                    // Uses nextTick to trigger the height change
                    setTimeout(function() {
                        that.container.style.height = '0px';
                        that.container.style.paddingTop = that.container.style.paddingBottom ='0px';
                        ch.util.classList(that.container).add('ch-fx-' + toggleEffects[fx]);
                    }, 0);
                } else {
                    setTimeout(function() {
                        ch.util.classList(that.container).add('ch-fx-' + toggleEffects[fx]);
                    }, 0);
                }
            } else {
                hideCallback();
            }

            return that;
        };

        /**
         * Shows or hides the component.
         * @function
         * @private
         */
        this._toggle = function () {

            if (that._shown) {
                that.hide();
            } else {
                that.show();
            }

            return that;
        };

        this.on('disable', this.hide);
    }

    ch.Collapsible = Collapsible;

}(this.ch));</code></pre>
        </article>
    </section>




                </div>

                <nav class="mesh-col-12 mesh-col-m-3 chico-nav">
                    <h2>Components</h2><ul><li><a href="ch.Autocomplete">Autocomplete</a></li><li><a href="ch.Bubble">Bubble</a></li><li><a href="ch.Calendar">Calendar</a></li><li><a href="ch.Carousel">Carousel</a></li><li><a href="ch.Component">Component</a></li><li><a href="ch.Condition">Condition</a></li><li><a href="ch.Countdown">Countdown</a></li><li><a href="ch.Datepicker">Datepicker</a></li><li><a href="ch.Dropdown">Dropdown</a></li><li><a href="ch.EventEmitter">EventEmitter</a></li><li><a href="ch.Expandable">Expandable</a></li><li><a href="ch.Form">Form</a></li><li><a href="ch.Layer">Layer</a></li><li><a href="ch.Menu">Menu</a></li><li><a href="ch.Modal">Modal</a></li><li><a href="ch.Popover">Popover</a></li><li><a href="ch.Positioner">Positioner</a></li><li><a href="ch.Tabs">Tabs</a></li><li><a href="ch.Tooltip">Tooltip</a></li><li><a href="ch.Transition">Transition</a></li><li><a href="ch.Validation">Validation</a></li><li><a href="ch.Viewport">Viewport</a></li><li><a href="ch.Zoom">Zoom</a></li></ul><h2>Namespaces</h2><ul><li><a href="ch">ch</a></li><li><a href="ch.shortcuts">shortcuts</a></li><li><a href="ch.support">support</a></li><li><a href="ch.util">util</a></li></ul><h2>Mixins</h2><ul><li><a href="ch.Collapsible">Collapsible</a></li><li><a href="ch.Content">Content</a></li></ul>
                </nav>
            </div>
        </section>
    </main>
</div>

{% javascript prism.js %}
